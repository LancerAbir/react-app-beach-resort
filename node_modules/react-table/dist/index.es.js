import React from 'react';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];

  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }

  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");

  return typeof key === "symbol" ? key : String(key);
}

var defaultColumn = {
  Cell: function Cell(_ref) {
    var _ref$cell$value = _ref.cell.value,
        value = _ref$cell$value === void 0 ? '' : _ref$cell$value;
    return String(value);
  },
  show: true,
  width: 150,
  minWidth: 0,
  maxWidth: Number.MAX_SAFE_INTEGER
}; // SSR has issues with useLayoutEffect still, so use useEffect during SSR

var safeUseLayoutEffect = typeof window !== 'undefined' && process.env.NODE_ENV === 'production' ? React.useLayoutEffect : React.useEffect; // Find the depth of the columns

function findMaxDepth(columns) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return columns.reduce(function (prev, curr) {
    if (curr.columns) {
      return Math.max(prev, findMaxDepth(curr.columns, depth + 1));
    }

    return depth;
  }, 0);
}
function decorateColumn(column, userDefaultColumn, parent, depth, index) {
  // Apply the userDefaultColumn
  column = _objectSpread2({}, defaultColumn, {}, userDefaultColumn, {}, column); // First check for string accessor

  var _column = column,
      id = _column.id,
      accessor = _column.accessor,
      Header = _column.Header;

  if (typeof accessor === 'string') {
    id = id || accessor;
    var accessorPath = accessor.split('.');

    accessor = function accessor(row) {
      return getBy(row, accessorPath);
    };
  }

  if (!id && typeof Header === 'string' && Header) {
    id = Header;
  }

  if (!id && column.columns) {
    console.error(column);
    throw new Error('A column ID (or unique "Header" value) is required!');
  }

  if (!id) {
    console.error(column);
    throw new Error('A column ID (or string accessor) is required!');
  }

  column = _objectSpread2({
    // Make sure there is a fallback header, just in case
    Header: function Header() {
      return React.createElement(React.Fragment, null, "\xA0");
    }
  }, column, {
    // Materialize and override this stuff
    id: id,
    accessor: accessor,
    parent: parent,
    depth: depth,
    index: index
  });
  return column;
} // Build the visible columns, headers and flat column list

function decorateColumnTree(columns, defaultColumn, parent) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return columns.map(function (column, columnIndex) {
    column = decorateColumn(column, defaultColumn, parent, depth, columnIndex);

    if (column.columns) {
      column.columns = decorateColumnTree(column.columns, defaultColumn, column, depth + 1);
    }

    return column;
  });
} // Build the header groups from the bottom up

function makeHeaderGroups(flatColumns, defaultColumn) {
  var headerGroups = []; // Build each header group from the bottom up

  var buildGroup = function buildGroup(columns, depth) {
    var headerGroup = {
      headers: []
    };
    var parentColumns = []; // Do any of these columns have parents?

    var hasParents = columns.some(function (col) {
      return col.parent;
    });
    columns.forEach(function (column) {
      // Are we the first column in this group?
      var isFirst = !parentColumns.length; // What is the latest (last) parent column?

      var latestParentColumn = [].concat(parentColumns).reverse()[0]; // If the column has a parent, add it if necessary

      if (column.parent) {
        var similarParentColumns = parentColumns.filter(function (d) {
          return d.originalId === column.parent.id;
        });

        if (isFirst || latestParentColumn.originalId !== column.parent.id) {
          parentColumns.push(_objectSpread2({}, column.parent, {
            originalId: column.parent.id,
            id: [column.parent.id, similarParentColumns.length].join('_')
          }));
        }
      } else if (hasParents) {
        // If other columns have parents, we'll need to add a place holder if necessary
        var originalId = [column.id, 'placeholder'].join('_');

        var _similarParentColumns = parentColumns.filter(function (d) {
          return d.originalId === originalId;
        });

        var placeholderColumn = decorateColumn({
          originalId: originalId,
          id: [column.id, 'placeholder', _similarParentColumns.length].join('_'),
          placeholderOf: column
        }, defaultColumn);

        if (isFirst || latestParentColumn.originalId !== placeholderColumn.originalId) {
          parentColumns.push(placeholderColumn);
        }
      } // Establish the new headers[] relationship on the parent


      if (column.parent || hasParents) {
        latestParentColumn = [].concat(parentColumns).reverse()[0];
        latestParentColumn.headers = latestParentColumn.headers || [];

        if (!latestParentColumn.headers.includes(column)) {
          latestParentColumn.headers.push(column);
        }
      }

      column.totalHeaderCount = column.headers ? column.headers.reduce(function (sum, header) {
        return sum + header.totalHeaderCount;
      }, 0) : 1; // Leaf node columns take up at least one count

      headerGroup.headers.push(column);
    });
    headerGroups.push(headerGroup);

    if (parentColumns.length) {
      buildGroup(parentColumns);
    }
  };

  buildGroup(flatColumns);
  return headerGroups.reverse();
}
function determineHeaderVisibility(instance) {
  var headers = instance.headers;

  var handleColumn = function handleColumn(column, parentVisible) {
    column.isVisible = parentVisible ? typeof column.show === 'function' ? column.show(instance) : !!column.show : false;
    var totalVisibleHeaderCount = 0;

    if (column.headers && column.headers.length) {
      column.headers.forEach(function (subColumn) {
        return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);
      });
    } else {
      totalVisibleHeaderCount = column.isVisible ? 1 : 0;
    }

    column.totalVisibleHeaderCount = totalVisibleHeaderCount;
    return totalVisibleHeaderCount;
  };

  var totalVisibleHeaderCount = 0;
  headers.forEach(function (subHeader) {
    return totalVisibleHeaderCount += handleColumn(subHeader, true);
  });
}
function getBy(obj, path, def) {
  if (!path) {
    return obj;
  }

  var pathObj = makePathArray(path);
  var val;

  try {
    val = pathObj.reduce(function (cursor, pathPart) {
      return cursor[pathPart];
    }, obj);
  } catch (e) {// continue regardless of error
  }

  return typeof val !== 'undefined' ? val : def;
}
function defaultOrderByFn(arr, funcs, dirs) {
  return _toConsumableArray(arr).sort(function (rowA, rowB) {
    for (var i = 0; i < funcs.length; i += 1) {
      var sortFn = funcs[i];
      var desc = dirs[i] === false || dirs[i] === 'desc';
      var sortInt = sortFn(rowA, rowB);

      if (sortInt !== 0) {
        return desc ? -sortInt : sortInt;
      }
    }

    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;
  });
}
function getFirstDefined() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  for (var i = 0; i < args.length; i += 1) {
    if (typeof args[i] !== 'undefined') {
      return args[i];
    }
  }
}
function defaultGroupByFn(rows, columnId) {
  return rows.reduce(function (prev, row, i) {
    // TODO: Might want to implement a key serializer here so
    // irregular column values can still be grouped if needed?
    var resKey = "".concat(row.values[columnId]);
    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];
    prev[resKey].push(row);
    return prev;
  }, {});
}
function getElementDimensions(element) {
  var rect = element.getBoundingClientRect();
  var style = window.getComputedStyle(element);
  var margins = {
    left: parseInt(style.marginLeft),
    right: parseInt(style.marginRight)
  };
  var padding = {
    left: parseInt(style.paddingLeft),
    right: parseInt(style.paddingRight)
  };
  return {
    left: Math.ceil(rect.left),
    width: Math.ceil(rect.width),
    outerWidth: Math.ceil(rect.width + margins.left + margins.right + padding.left + padding.right),
    marginLeft: margins.left,
    marginRight: margins.right,
    paddingLeft: padding.left,
    paddingRight: padding.right,
    scrollWidth: element.scrollWidth
  };
}
function flexRender(Comp, props) {
  return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;
}

function isClassComponent(component) {
  return typeof component === 'function' && !!function () {
    var proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  }();
}

function isFunctionComponent(component) {
  return typeof component === 'function';
}

function isReactComponent(component) {
  return isClassComponent(component) || isFunctionComponent(component);
}

var mergeProps = function mergeProps() {
  var props = {};

  for (var _len2 = arguments.length, groups = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    groups[_key2] = arguments[_key2];
  }

  groups.forEach(function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$style = _ref2.style,
        style = _ref2$style === void 0 ? {} : _ref2$style,
        className = _ref2.className,
        rest = _objectWithoutProperties(_ref2, ["style", "className"]);

    props = _objectSpread2({}, props, {}, rest, {
      style: _objectSpread2({}, props.style || {}, {}, style),
      className: [props.className, className].filter(Boolean).join(' ')
    });
  });

  if (props.className === '') {
    delete props.className;
  }

  return props;
};
var applyHooks = function applyHooks(hooks, initial) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    args[_key3 - 2] = arguments[_key3];
  }

  return hooks.reduce(function (prev, next) {
    var nextValue = next.apply(void 0, [prev].concat(args));

    if (typeof nextValue === 'undefined') {
      throw new Error('React Table: A hook just returned undefined! This is not allowed.');
    }

    return nextValue;
  }, initial);
};
var applyPropHooks = function applyPropHooks(hooks) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  return hooks.reduce(function (prev, next) {
    return mergeProps(prev, next.apply(void 0, args));
  }, {});
};
var warnUnknownProps = function warnUnknownProps(props) {
  if (Object.keys(props).length) {
    throw new Error("Unknown options passed to useReactTable:\n\n".concat(JSON.stringify(props, null, 2)));
  }
};
function sum(arr) {
  return arr.reduce(function (prev, curr) {
    return prev + curr;
  }, 0);
}
function isFunction(a) {
  if (typeof a === 'function') {
    return a;
  }
}
function flattenBy(columns, childKey) {
  var flatColumns = [];

  var recurse = function recurse(columns) {
    columns.forEach(function (d) {
      if (!d[childKey]) {
        flatColumns.push(d);
      } else {
        recurse(d[childKey]);
      }
    });
  };

  recurse(columns);
  return flatColumns;
}
function ensurePluginOrder(plugins, befores, pluginName, afters) {
  var pluginIndex = plugins.findIndex(function (plugin) {
    return plugin.pluginName === pluginName;
  });

  if (pluginIndex === -1) {
    throw new Error("The plugin ".concat(pluginName, " was not found in the plugin list!\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\n\n  ").concat(pluginName, ".pluginName = '").concat(pluginName, "'\n"));
  }

  befores.forEach(function (before) {
    var beforeIndex = plugins.findIndex(function (plugin) {
      return plugin.pluginName === before;
    });

    if (beforeIndex > -1 && beforeIndex > pluginIndex) {
      throw new Error("React Table: The ".concat(pluginName, " plugin hook must be placed after the ").concat(before, " plugin hook!"));
    }
  });
  afters.forEach(function (after) {
    var afterIndex = plugins.findIndex(function (plugin) {
      return plugin.pluginName === after;
    });

    if (afterIndex > -1 && afterIndex < pluginIndex) {
      throw new Error("React Table: The ".concat(pluginName, " plugin hook must be placed before the ").concat(after, " plugin hook!"));
    }
  });
}
function expandRows(rows, _ref3) {
  var manualExpandedKey = _ref3.manualExpandedKey,
      expanded = _ref3.expanded,
      _ref3$expandSubRows = _ref3.expandSubRows,
      expandSubRows = _ref3$expandSubRows === void 0 ? true : _ref3$expandSubRows;
  var expandedRows = [];

  var handleRow = function handleRow(row) {
    var key = row.path.join('.');
    row.isExpanded = row.original && row.original[manualExpandedKey] || expanded.includes(key);
    row.canExpand = row.subRows && !!row.subRows.length;
    expandedRows.push(row);

    if (expandSubRows && row.subRows && row.subRows.length && row.isExpanded) {
      row.subRows.forEach(handleRow);
    }
  };

  rows.forEach(handleRow);
  return expandedRows;
}
function functionalUpdate(updater, old) {
  return typeof updater === 'function' ? updater(old) : updater;
} //

function makePathArray(obj) {
  return flattenDeep(obj) // remove all periods in parts
  .map(function (d) {
    return String(d).replace('.', '_');
  }) // join parts using period
  .join('.') // replace brackets with periods
  .replace(/\[/g, '.').replace(/\]/g, '') // split it back out on periods
  .split('.');
}

function flattenDeep(arr) {
  var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!Array.isArray(arr)) {
    newArr.push(arr);
  } else {
    for (var i = 0; i < arr.length; i += 1) {
      flattenDeep(arr[i], newArr);
    }
  }

  return newArr;
}

var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  defaultColumn: defaultColumn,
  safeUseLayoutEffect: safeUseLayoutEffect,
  findMaxDepth: findMaxDepth,
  decorateColumn: decorateColumn,
  decorateColumnTree: decorateColumnTree,
  makeHeaderGroups: makeHeaderGroups,
  determineHeaderVisibility: determineHeaderVisibility,
  getBy: getBy,
  defaultOrderByFn: defaultOrderByFn,
  getFirstDefined: getFirstDefined,
  defaultGroupByFn: defaultGroupByFn,
  getElementDimensions: getElementDimensions,
  flexRender: flexRender,
  mergeProps: mergeProps,
  applyHooks: applyHooks,
  applyPropHooks: applyPropHooks,
  warnUnknownProps: warnUnknownProps,
  sum: sum,
  isFunction: isFunction,
  flattenBy: flattenBy,
  ensurePluginOrder: ensurePluginOrder,
  expandRows: expandRows,
  functionalUpdate: functionalUpdate
});

var renderErr = 'You must specify a valid render component. This could be "column.Cell", "column.Header", "column.Filter", "column.Aggregated" or any other custom renderer component.';
var actions = {
  init: 'init'
};
var reducerHandlers = {};
var defaultInitialState = {};
var defaultColumnInstance = {};

var defaultReducer = function defaultReducer(state, action, prevState) {
  return state;
};

var defaultGetSubRows = function defaultGetSubRows(row, index) {
  return row.subRows || [];
};

var defaultGetRowId = function defaultGetRowId(row, index) {
  return index;
};

var useTable = function useTable(props) {
  // Destructure props
  var data = props.data,
      userColumns = props.columns,
      _props$initialState = props.initialState,
      initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState,
      _props$defaultColumn = props.defaultColumn,
      defaultColumn = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn,
      _props$getSubRows = props.getSubRows,
      getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows,
      _props$getRowId = props.getRowId,
      getRowId = _props$getRowId === void 0 ? defaultGetRowId : _props$getRowId,
      _props$reducer = props.reducer,
      userReducer = _props$reducer === void 0 ? defaultReducer : _props$reducer,
      debug = props.debug;
  debug = process.env.NODE_ENV === 'production' ? false : debug;

  var reducer = function reducer(state, action) {
    var nextState = Object.keys(reducerHandlers).map(function (key) {
      return reducerHandlers[key];
    }).reduce(function (state, handler) {
      return handler(state, action) || state;
    }, state);
    nextState = userReducer(nextState, action, state);

    if (process.env.NODE_ENV !== 'production' && debug) {
      console.log('');
      console.log('React Table Action: ', action);
      console.log('New State: ', nextState);
    }

    return nextState;
  }; // But use the users table state if provided


  var _React$useReducer = React.useReducer(reducer, undefined, function () {
    return reducer(initialState, {
      type: actions.init
    });
  }),
      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
      state = _React$useReducer2[0],
      originalDispatch = _React$useReducer2[1]; // The table instance ref


  var instanceRef = React.useRef({});
  var dispatch = React.useCallback(function (action) {
    if (!action.type) {
      if (process.env.NODE_ENV !== 'production') {
        console.info({
          action: action
        });
        throw new Error('Unknown Action Type! ðŸ‘†');
      }

      throw new Error();
    }

    originalDispatch(_objectSpread2({}, action, {
      instanceRef: instanceRef
    }));
  }, []);

  for (var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    plugins[_key - 1] = arguments[_key];
  }

  Object.assign(instanceRef.current, _objectSpread2({}, props, {
    data: data,
    // The raw data
    state: state,
    // The state dispatcher
    dispatch: dispatch,
    // The resolved table state
    plugins: plugins,
    // All resolved plugins
    hooks: {
      columnsBeforeHeaderGroups: [],
      columnsBeforeHeaderGroupsDeps: [],
      useBeforeDimensions: [],
      useMain: [],
      useRows: [],
      prepareRow: [],
      getTableProps: [],
      getTableBodyProps: [],
      getRowProps: [],
      getHeaderGroupProps: [],
      getHeaderProps: [],
      getCellProps: []
    }
  })); // Allow plugins to register hooks

  if (process.env.NODE_ENV !== 'production' && debug) console.time('plugins');
  plugins.filter(Boolean).forEach(function (plugin) {
    plugin(instanceRef.current.hooks);
  });
  if (process.env.NODE_ENV !== 'production' && debug) console.timeEnd('plugins'); // Decorate All the columns

  var columns = React.useMemo(function () {
    return decorateColumnTree(userColumns, defaultColumn);
  }, [defaultColumn, userColumns]); // Get the flat list of all columns and allow hooks to decorate
  // those columns (and trigger this memoization via deps)

  var flatColumns = React.useMemo(function () {
    if (process.env.NODE_ENV !== 'production' && debug) console.time('hooks.columnsBeforeHeaderGroups');
    var newColumns = applyHooks(instanceRef.current.hooks.columnsBeforeHeaderGroups, flattenBy(columns, 'columns'), instanceRef.current);
    if (process.env.NODE_ENV !== 'production' && debug) console.timeEnd('hooks.columnsBeforeHeaderGroups');
    return newColumns;
  }, [columns, debug].concat(_toConsumableArray(applyHooks(instanceRef.current.hooks.columnsBeforeHeaderGroupsDeps, [], instanceRef.current)))); // Make the headerGroups

  var headerGroups = React.useMemo(function () {
    return makeHeaderGroups(flatColumns, defaultColumn);
  }, [defaultColumn, flatColumns]);
  var headers = React.useMemo(function () {
    return headerGroups[0].headers;
  }, [headerGroups]);
  Object.assign(instanceRef.current, {
    columns: columns,
    flatColumns: flatColumns,
    headerGroups: headerGroups,
    headers: headers
  }); // Access the row model

  var _React$useMemo = React.useMemo(function () {
    if (process.env.NODE_ENV !== 'production' && debug) console.time('getAccessedRows');
    var flatRows = []; // Access the row's data

    var accessRow = function accessRow(originalRow, i) {
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      // Keep the original reference around
      var original = originalRow;
      var rowId = getRowId(originalRow, i); // Make the new path for the row

      var path = [].concat(_toConsumableArray(parentPath), [rowId]);
      var row = {
        original: original,
        index: i,
        path: path,
        // used to create a key for each row even if not nested
        depth: depth,
        cells: [{}] // This is a dummy cell

      };
      flatRows.push(row); // Process any subRows

      var subRows = getSubRows(originalRow, i);

      if (subRows) {
        row.subRows = subRows.map(function (d, i) {
          return accessRow(d, i, depth + 1, path);
        });
      } // Override common array functions (and the dummy cell's getCellProps function)
      // to show an error if it is accessed without calling prepareRow


      var unpreparedAccessWarning = function unpreparedAccessWarning() {
        throw new Error('React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.');
      };

      row.cells.map = unpreparedAccessWarning;
      row.cells.filter = unpreparedAccessWarning;
      row.cells.forEach = unpreparedAccessWarning;
      row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values

      row.values = {};
      flatColumns.forEach(function (column) {
        row.values[column.id] = column.accessor ? column.accessor(originalRow, i, {
          subRows: subRows,
          depth: depth,
          data: data
        }) : undefined;
      });
      return row;
    }; // Use the resolved data


    var accessedData = data.map(function (d, i) {
      return accessRow(d, i);
    });
    if (process.env.NODE_ENV !== 'production' && debug) console.timeEnd('getAccessedRows');
    return [accessedData, flatRows];
  }, [debug, data, getRowId, getSubRows, flatColumns]),
      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
      rows = _React$useMemo2[0],
      flatRows = _React$useMemo2[1];

  instanceRef.current.rows = rows;
  instanceRef.current.flatRows = flatRows; // Determine column visibility

  determineHeaderVisibility(instanceRef.current); // Provide a flat header list for utilities

  instanceRef.current.flatHeaders = headerGroups.reduce(function (all, headerGroup) {
    return [].concat(_toConsumableArray(all), _toConsumableArray(headerGroup.headers));
  }, []);
  if (process.env.NODE_ENV !== 'production' && debug) console.time('hooks.useBeforeDimensions');
  instanceRef.current = applyHooks(instanceRef.current.hooks.useBeforeDimensions, instanceRef.current);
  if (process.env.NODE_ENV !== 'production' && debug) console.timeEnd('hooks.useBeforeDimensions');
  calculateDimensions(instanceRef.current);
  if (process.env.NODE_ENV !== 'production' && debug) console.time('hooks.useMain');
  instanceRef.current = applyHooks(instanceRef.current.hooks.useMain, instanceRef.current);
  if (process.env.NODE_ENV !== 'production' && debug) console.timeEnd('hooks.useMain'); // Each materialized header needs to be assigned a render function and other
  // prop getter properties here.

  instanceRef.current.flatHeaders.forEach(function (column) {
    // Give columns/headers rendering power
    column.render = function (type) {
      var userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var Comp = typeof type === 'string' ? column[type] : type;

      if (typeof Comp === 'undefined') {
        throw new Error(renderErr);
      }

      return flexRender(Comp, _objectSpread2({}, instanceRef.current, {
        column: column
      }, userProps));
    }; // Give columns/headers a default getHeaderProps


    column.getHeaderProps = function (props) {
      return mergeProps({
        key: ['header', column.id].join('_'),
        colSpan: column.totalVisibleHeaderCount
      }, applyPropHooks(instanceRef.current.hooks.getHeaderProps, column, instanceRef.current), props);
    };
  });
  instanceRef.current.headerGroups.forEach(function (headerGroup, i) {
    // Filter out any headers and headerGroups that don't have visible columns
    headerGroup.headers = headerGroup.headers.filter(function (header) {
      var recurse = function recurse(headers) {
        return headers.filter(function (header) {
          if (header.headers) {
            return recurse(header.headers);
          }

          return header.isVisible;
        }).length;
      };

      if (header.headers) {
        return recurse(header.headers);
      }

      return header.isVisible;
    }); // Give headerGroups getRowProps

    if (headerGroup.headers.length) {
      headerGroup.getHeaderGroupProps = function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return mergeProps({
          key: ["header".concat(i)].join('_')
        }, applyPropHooks(instanceRef.current.hooks.getHeaderGroupProps, headerGroup, instanceRef.current), props);
      };

      return true;
    }
  }); // Run the rows (this could be a dangerous hook with a ton of data)

  if (process.env.NODE_ENV !== 'production' && debug) console.time('hooks.useRows');
  instanceRef.current.rows = applyHooks(instanceRef.current.hooks.useRows, instanceRef.current.rows, instanceRef.current);
  if (process.env.NODE_ENV !== 'production' && debug) console.timeEnd('hooks.useRows'); // The prepareRow function is absolutely necessary and MUST be called on
  // any rows the user wishes to be displayed.

  instanceRef.current.prepareRow = React.useCallback(function (row) {
    row.getRowProps = function (props) {
      return mergeProps({
        key: ['row'].concat(_toConsumableArray(row.path)).join('_')
      }, applyPropHooks(instanceRef.current.hooks.getRowProps, row, instanceRef.current), props);
    }; // Build the visible cells for each row


    row.cells = instanceRef.current.flatColumns.filter(function (d) {
      return d.isVisible;
    }).map(function (column) {
      var cell = {
        column: column,
        row: row,
        value: row.values[column.id]
      }; // Give each cell a getCellProps base

      cell.getCellProps = function (props) {
        var columnPathStr = [].concat(_toConsumableArray(row.path), [column.id]).join('_');
        return mergeProps({
          key: ['cell', columnPathStr].join('_')
        }, applyPropHooks(instanceRef.current.hooks.getCellProps, cell, instanceRef.current), props);
      }; // Give each cell a renderer function (supports multiple renderers)


      cell.render = function (type) {
        var userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var Comp = typeof type === 'string' ? column[type] : type;

        if (typeof Comp === 'undefined') {
          throw new Error(renderErr);
        }

        return flexRender(Comp, _objectSpread2({}, instanceRef.current, {
          column: column,
          row: row,
          cell: cell
        }, userProps));
      };

      return cell;
    }); // need to apply any row specific hooks (useExpanded requires this)

    applyHooks(instanceRef.current.hooks.prepareRow, row, instanceRef.current);
  }, []);

  instanceRef.current.getTableProps = function (userProps) {
    return mergeProps(applyPropHooks(instanceRef.current.hooks.getTableProps, instanceRef.current), userProps);
  };

  instanceRef.current.getTableBodyProps = function (userProps) {
    return mergeProps(applyPropHooks(instanceRef.current.hooks.getTableBodyProps, instanceRef.current), userProps);
  };

  return instanceRef.current;
};

function calculateDimensions(instance) {
  var headers = instance.headers;
  instance.totalColumnsWidth = calculateHeaderWidths(headers);
}

function calculateHeaderWidths(headers) {
  var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var sumTotalWidth = 0;
  headers.forEach(function (header) {
    var subHeaders = header.headers;
    header.totalLeft = left;

    if (subHeaders && subHeaders.length) {
      header.totalWidth = calculateHeaderWidths(subHeaders, left);
    } else {
      header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);
    }

    if (header.isVisible) {
      left += header.totalWidth;
      sumTotalWidth += header.totalWidth;
    }
  });
  return sumTotalWidth;
}

var pluginName = 'useExpanded'; // Actions

actions.toggleExpandedByPath = 'toggleExpandedByPath';
actions.resetExpanded = 'resetExpanded'; // Reducer

reducerHandlers[pluginName] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      expanded: []
    }, state);
  }

  if (action.type === actions.resetExpanded) {
    return _objectSpread2({}, state, {
      expanded: []
    });
  }

  if (action.type === actions.toggleExpandedByPath) {
    var path = action.path,
        expanded = action.expanded;
    var key = path.join('.');
    var exists = state.expanded.includes(key);
    var shouldExist = typeof set !== 'undefined' ? expanded : !exists;
    var newExpanded = new Set(state.expanded);

    if (!exists && shouldExist) {
      newExpanded.add(key);
    } else if (exists && !shouldExist) {
      newExpanded.delete(key);
    } else {
      return state;
    }

    return _objectSpread2({}, state, {
      expanded: _toConsumableArray(newExpanded.values())
    });
  }
};

var useExpanded = function useExpanded(hooks) {
  hooks.getExpandedToggleProps = [];
  hooks.useMain.push(useMain);
};
useExpanded.pluginName = pluginName;

var defaultGetResetExpandedDeps = function defaultGetResetExpandedDeps(_ref) {
  var data = _ref.data;
  return [data];
};

function useMain(instance) {
  var debug = instance.debug,
      rows = instance.rows,
      _instance$manualExpan = instance.manualExpandedKey,
      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,
      _instance$paginateExp = instance.paginateExpandedRows,
      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,
      _instance$expandSubRo = instance.expandSubRows,
      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,
      hooks = instance.hooks,
      expanded = instance.state.expanded,
      dispatch = instance.dispatch,
      _instance$getResetExp = instance.getResetExpandedDeps,
      getResetExpandedDeps = _instance$getResetExp === void 0 ? defaultGetResetExpandedDeps : _instance$getResetExp; // Bypass any effects from firing when this changes

  var isMountedRef = React.useRef();
  safeUseLayoutEffect(function () {
    if (isMountedRef.current) {
      dispatch({
        type: actions.resetExpanded
      });
    }

    isMountedRef.current = true;
  }, [dispatch].concat(_toConsumableArray(getResetExpandedDeps ? getResetExpandedDeps(instance) : [])));

  var toggleExpandedByPath = function toggleExpandedByPath(path, expanded) {
    dispatch({
      type: actions.toggleExpandedByPath,
      path: path,
      expanded: expanded
    });
  }; // use reference to avoid memory leak in #1608


  var instanceRef = React.useRef();
  instanceRef.current = instance;
  hooks.prepareRow.push(function (row) {
    row.toggleExpanded = function (set) {
      return toggleExpandedByPath(row.path, set);
    };

    row.getExpandedToggleProps = function (props) {
      return mergeProps({
        onClick: function onClick(e) {
          e.persist();
          row.toggleExpanded();
        },
        style: {
          cursor: 'pointer'
        },
        title: 'Toggle Expanded'
      }, applyPropHooks(instanceRef.current.hooks.getExpandedToggleProps, row, instanceRef.current), props);
    };

    return row;
  });
  var expandedRows = React.useMemo(function () {
    if (process.env.NODE_ENV !== 'production' && debug) console.info('getExpandedRows');

    if (paginateExpandedRows) {
      return expandRows(rows, {
        manualExpandedKey: manualExpandedKey,
        expanded: expanded,
        expandSubRows: expandSubRows
      });
    }

    return rows;
  }, [debug, paginateExpandedRows, rows, manualExpandedKey, expanded, expandSubRows]);
  var expandedDepth = findExpandedDepth(expanded);
  return _objectSpread2({}, instance, {
    toggleExpandedByPath: toggleExpandedByPath,
    expandedDepth: expandedDepth,
    rows: expandedRows
  });
}

function findExpandedDepth(expanded) {
  var maxDepth = 0;
  expanded.forEach(function (key) {
    var path = key.split('.');
    maxDepth = Math.max(maxDepth, path.length);
  });
  return maxDepth;
}

var text = function text(rows, id, filterValue) {
  rows = rows.filter(function (row) {
    var rowValue = row.values[id];
    return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());
  });
  return rows;
};

text.autoRemove = function (val) {
  return !val;
};

var exactText = function exactText(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;
  });
};

exactText.autoRemove = function (val) {
  return !val;
};

var exactTextCase = function exactTextCase(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;
  });
};

exactTextCase.autoRemove = function (val) {
  return !val;
};

var includes = function includes(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return filterValue.includes(rowValue);
  });
};

includes.autoRemove = function (val) {
  return !val || !val.length;
};

var includesAll = function includesAll(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue && rowValue.length && filterValue.every(function (val) {
      return rowValue.includes(val);
    });
  });
};

includesAll.autoRemove = function (val) {
  return !val || !val.length;
};

var exact = function exact(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue === filterValue;
  });
};

exact.autoRemove = function (val) {
  return typeof val === 'undefined';
};

var equals = function equals(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq

    return rowValue == filterValue;
  });
};

equals.autoRemove = function (val) {
  return val == null;
};

var between = function between(rows, id, filterValue) {
  var _ref = filterValue || [],
      _ref2 = _slicedToArray(_ref, 2),
      min = _ref2[0],
      max = _ref2[1];

  min = typeof min === 'number' ? min : -Infinity;
  max = typeof max === 'number' ? max : Infinity;

  if (min > max) {
    var temp = min;
    min = max;
    max = temp;
  }

  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue >= min && rowValue <= max;
  });
};

between.autoRemove = function (val) {
  return !val || typeof val[0] !== 'number' && typeof val[1] !== 'number';
};

var filterTypes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  text: text,
  exactText: exactText,
  exactTextCase: exactTextCase,
  includes: includes,
  includesAll: includesAll,
  exact: exact,
  equals: equals,
  between: between
});

var pluginName$1 = 'useFilters'; // Actions

actions.resetFilters = 'resetFilters';
actions.setFilter = 'setFilter';
actions.setAllFilters = 'setAllFilters'; // Reducer

reducerHandlers[pluginName$1] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      filters: {}
    }, state);
  }

  if (action.type === actions.resetFilters) {
    return _objectSpread2({}, state, {
      filters: {}
    });
  }

  if (action.type === actions.setFilter) {
    var columnId = action.columnId,
        filterValue = action.filterValue,
        _action$instanceRef$c = action.instanceRef.current,
        flatColumns = _action$instanceRef$c.flatColumns,
        userFilterTypes = _action$instanceRef$c.userFilterTypes;
    var column = flatColumns.find(function (d) {
      return d.id === columnId;
    });

    if (!column) {
      throw new Error("React-Table: Could not find a column with id: ".concat(columnId));
    }

    var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);
    var newFilter = functionalUpdate(filterValue, state.filters[columnId]); //

    if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {
      var _state$filters = state.filters,
          remove = _state$filters[columnId],
          newFilters = _objectWithoutProperties(_state$filters, [columnId].map(_toPropertyKey));

      return _objectSpread2({}, state, {
        filters: newFilters
      });
    }

    return _objectSpread2({}, state, {
      filters: _objectSpread2({}, state.filters, _defineProperty({}, columnId, newFilter))
    });
  }

  if (action.type === actions.setAllFilters) {
    var filters = action.filters,
        _action$instanceRef$c2 = action.instanceRef.current,
        _flatColumns = _action$instanceRef$c2.flatColumns,
        _userFilterTypes = _action$instanceRef$c2.filterTypes;

    var _newFilters = functionalUpdate(filters, state.filters); // Filter out undefined values


    Object.keys(_newFilters).forEach(function (id) {
      var newFilter = _newFilters[id];

      var column = _flatColumns.find(function (d) {
        return d.id === id;
      });

      var filterMethod = getFilterMethod(column.filter, _userFilterTypes || {}, filterTypes);

      if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {
        delete _newFilters[id];
      }
    });
    return _objectSpread2({}, state, {
      filters: _newFilters
    });
  }
};

var useFilters = function useFilters(hooks) {
  hooks.useMain.push(useMain$1);
};
useFilters.pluginName = pluginName$1;

function useMain$1(instance) {
  var debug = instance.debug,
      rows = instance.rows,
      flatRows = instance.flatRows,
      flatColumns = instance.flatColumns,
      userFilterTypes = instance.filterTypes,
      manualFilters = instance.manualFilters,
      _instance$defaultCanF = instance.defaultCanFilter,
      defaultCanFilter = _instance$defaultCanF === void 0 ? false : _instance$defaultCanF,
      disableFilters = instance.disableFilters,
      filters = instance.state.filters,
      dispatch = instance.dispatch,
      _instance$getResetFil = instance.getResetFiltersDeps,
      getResetFiltersDeps = _instance$getResetFil === void 0 ? false : _instance$getResetFil;
  var preFilteredRows = rows;
  var preFilteredFlatRows = flatRows; // Bypass any effects from firing when this changes

  var isMountedRef = React.useRef();
  safeUseLayoutEffect(function () {
    if (isMountedRef.current) {
      dispatch({
        type: actions.resetFilters
      });
    }

    isMountedRef.current = true;
  }, [dispatch].concat(_toConsumableArray(getResetFiltersDeps ? getResetFiltersDeps(instance) : [])));

  var setFilter = function setFilter(columnId, filterValue) {
    dispatch({
      type: actions.setFilter,
      columnId: columnId,
      filterValue: filterValue
    });
  };

  var setAllFilters = function setAllFilters(filters) {
    dispatch({
      type: actions.setAllFilters,
      filters: filters
    });
  };

  flatColumns.forEach(function (column) {
    var id = column.id,
        accessor = column.accessor,
        columnDefaultCanFilter = column.defaultCanFilter,
        columnDisableFilters = column.disableFilters; // Determine if a column is filterable

    column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value

    column.setFilter = function (val) {
      return setFilter(column.id, val);
    }; // Provide the current filter value to the column for
    // convenience


    column.filterValue = filters[id];
  }); // TODO: Create a filter cache for incremental high speed multi-filtering
  // This gets pretty complicated pretty fast, since you have to maintain a
  // cache for each row group (top-level rows, and each row's recursive subrows)
  // This would make multi-filtering a lot faster though. Too far?

  var _React$useMemo = React.useMemo(function () {
    if (manualFilters || !Object.keys(filters).length) {
      return {
        filteredRows: rows,
        filteredFlatRows: flatRows
      };
    }

    var filteredFlatRows = [];
    if (process.env.NODE_ENV !== 'production' && debug) console.info('getFilteredRows'); // Filters top level and nested rows

    var filterRows = function filterRows(rows) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var filteredRows = rows;
      filteredRows = Object.entries(filters).reduce(function (filteredSoFar, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            columnId = _ref2[0],
            filterValue = _ref2[1];

        // Find the filters column
        var column = flatColumns.find(function (d) {
          return d.id === columnId;
        });

        if (!column) {
          return filteredSoFar;
        }

        if (depth === 0) {
          column.preFilteredRows = filteredSoFar;
        }

        var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);

        if (!filterMethod) {
          console.warn("Could not find a valid 'column.filter' for column with the ID: ".concat(column.id, "."));
          return filteredSoFar;
        } // Pass the rows, id, filterValue and column to the filterMethod
        // to get the filtered rows back


        column.filteredRows = filterMethod(filteredSoFar, columnId, filterValue, column);
        return column.filteredRows;
      }, rows); // Apply the filter to any subRows
      // We technically could do this recursively in the above loop,
      // but that would severely hinder the API for the user, since they
      // would be required to do that recursion in some scenarios

      filteredRows = filteredRows.map(function (row) {
        filteredFlatRows.push(row);

        if (!row.subRows) {
          return row;
        }

        return _objectSpread2({}, row, {
          subRows: row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows
        });
      });
      return filteredRows;
    };

    return {
      filteredRows: filterRows(rows),
      filteredFlatRows: filteredFlatRows
    };
  }, [manualFilters, filters, debug, rows, flatRows, flatColumns, userFilterTypes]),
      filteredRows = _React$useMemo.filteredRows,
      filteredFlatRows = _React$useMemo.filteredFlatRows;

  React.useMemo(function () {
    // Now that each filtered column has it's partially filtered rows,
    // lets assign the final filtered rows to all of the other columns
    var nonFilteredColumns = flatColumns.filter(function (column) {
      return !Object.keys(filters).includes(column.id);
    }); // This essentially enables faceted filter options to be built easily
    // using every column's preFilteredRows value

    nonFilteredColumns.forEach(function (column) {
      column.preFilteredRows = filteredRows;
      column.filteredRows = filteredRows;
    });
  }, [filteredRows, filters, flatColumns]);
  return _objectSpread2({}, instance, {
    setFilter: setFilter,
    setAllFilters: setAllFilters,
    preFilteredRows: preFilteredRows,
    preFilteredFlatRows: preFilteredFlatRows,
    rows: filteredRows,
    flatRows: filteredFlatRows
  });
}

function shouldAutoRemove(autoRemove, value) {
  return autoRemove ? autoRemove(value) : typeof value === 'undefined';
}

function getFilterMethod(filter, userFilterTypes, filterTypes) {
  return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;
}

function sum$1(values, rows) {
  return values.reduce(function (sum, next) {
    return sum + next;
  }, 0);
}
function average(values, rows) {
  return Math.round(sum$1(values) / values.length * 100) / 100;
}
function median(values) {
  values = values.length ? values : [0];
  var min = Math.min.apply(Math, _toConsumableArray(values));
  var max = Math.max.apply(Math, _toConsumableArray(values));
  return (min + max) / 2;
}
function uniqueCount(values) {
  return new Set(values).size;
}
function count(values) {
  return values.length;
}

var aggregations = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sum: sum$1,
  average: average,
  median: median,
  uniqueCount: uniqueCount,
  count: count
});

var pluginName$2 = 'useGroupBy'; // Actions

actions.resetGroupBy = 'resetGroupBy';
actions.toggleGroupBy = 'toggleGroupBy'; // Reducer

reducerHandlers[pluginName$2] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      groupBy: []
    }, state);
  }

  if (action.type === actions.resetGroupBy) {
    return _objectSpread2({}, state, {
      groupBy: []
    });
  }

  if (action.type === actions.toggleGroupBy) {
    var columnId = action.columnId,
        toggle = action.toggle;
    var resolvedToggle = typeof toggle !== 'undefined' ? toggle : !state.groupBy.includes(columnId);

    if (resolvedToggle) {
      return _objectSpread2({}, state, {
        groupBy: [].concat(_toConsumableArray(state.groupBy), [columnId])
      });
    }

    return _objectSpread2({}, state, {
      groupBy: state.groupBy.filter(function (d) {
        return d !== columnId;
      })
    });
  }
};

var useGroupBy = function useGroupBy(hooks) {
  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups);
  hooks.columnsBeforeHeaderGroupsDeps.push(function (deps, instance) {
    deps.push(instance.state.groupBy);
    return deps;
  });
  hooks.useMain.push(useMain$2);
};
useGroupBy.pluginName = pluginName$2;

function columnsBeforeHeaderGroups(flatColumns, _ref) {
  var groupBy = _ref.state.groupBy;
  // Sort grouped columns to the start of the column list
  // before the headers are built
  var groupByColumns = groupBy.map(function (g) {
    return flatColumns.find(function (col) {
      return col.id === g;
    });
  });
  var nonGroupByColumns = flatColumns.filter(function (col) {
    return !groupBy.includes(col.id);
  }); // If a groupByBoundary column is found, place the groupBy's after it

  var groupByBoundaryColumnIndex = flatColumns.findIndex(function (column) {
    return column.groupByBoundary;
  }) + 1;
  return [].concat(_toConsumableArray(nonGroupByColumns.slice(0, groupByBoundaryColumnIndex)), _toConsumableArray(groupByColumns), _toConsumableArray(nonGroupByColumns.slice(groupByBoundaryColumnIndex)));
}

var defaultUserAggregations = {};

function useMain$2(instance) {
  var debug = instance.debug,
      rows = instance.rows,
      flatRows = instance.flatRows,
      flatColumns = instance.flatColumns,
      flatHeaders = instance.flatHeaders,
      _instance$groupByFn = instance.groupByFn,
      groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn,
      manualGroupBy = instance.manualGroupBy,
      defaultCanGroupBy = instance.defaultCanGroupBy,
      disableGroupBy = instance.disableGroupBy,
      _instance$aggregation = instance.aggregations,
      userAggregations = _instance$aggregation === void 0 ? defaultUserAggregations : _instance$aggregation,
      hooks = instance.hooks,
      plugins = instance.plugins,
      groupBy = instance.state.groupBy,
      dispatch = instance.dispatch;
  ensurePluginOrder(plugins, [], 'useGroupBy', ['useSortBy', 'useExpanded']);
  flatColumns.forEach(function (column) {
    var id = column.id,
        accessor = column.accessor,
        defaultColumnGroupBy = column.defaultGroupBy,
        columnDisableGroupBy = column.disableGroupBy;
    column.isGrouped = groupBy.includes(id);
    column.groupedIndex = groupBy.indexOf(id);
    column.canGroupBy = accessor ? getFirstDefined(columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(defaultColumnGroupBy, defaultCanGroupBy, false);

    if (column.canGroupBy) {
      column.toggleGroupBy = function () {
        return toggleGroupBy(column.id);
      };
    }

    column.Aggregated = column.Aggregated || column.Cell;
  });

  var toggleGroupBy = function toggleGroupBy(columnId, toggle) {
    dispatch({
      type: actions.toggleGroupBy,
      columnId: columnId,
      toggle: toggle
    });
  };

  hooks.getGroupByToggleProps = []; // use reference to avoid memory leak in #1608

  var instanceRef = React.useRef();
  instanceRef.current = instance;
  flatHeaders.forEach(function (header) {
    var canGroupBy = header.canGroupBy;

    header.getGroupByToggleProps = function (props) {
      return mergeProps({
        onClick: canGroupBy ? function (e) {
          e.persist();
          header.toggleGroupBy();
        } : undefined,
        style: {
          cursor: canGroupBy ? 'pointer' : undefined
        },
        title: 'Toggle GroupBy'
      }, applyPropHooks(instanceRef.current.hooks.getGroupByToggleProps, header, instanceRef.current), props);
    };
  });
  hooks.prepareRow.push(function (row) {
    row.cells.forEach(function (cell) {
      // Grouped cells are in the groupBy and the pivot cell for the row
      cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Repeated cells are any columns in the groupBy that are not grouped

      cell.isRepeatedValue = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows

      cell.isAggregated = !cell.isGrouped && !cell.isRepeatedValue && row.canExpand;
    });
    return row;
  });

  var _React$useMemo = React.useMemo(function () {
    if (manualGroupBy || !groupBy.length) {
      return [rows, flatRows];
    }

    if (process.env.NODE_ENV !== 'production' && debug) console.info('getGroupedRows'); // Find the columns that can or are aggregating
    // Uses each column to aggregate rows into a single value

    var aggregateRowsToValues = function aggregateRowsToValues(rows, isAggregated) {
      var values = {};
      flatColumns.forEach(function (column) {
        // Don't aggregate columns that are in the groupBy
        if (groupBy.includes(column.id)) {
          values[column.id] = rows[0] ? rows[0].values[column.id] : null;
          return;
        }

        var columnValues = rows.map(function (d) {
          return d.values[column.id];
        });
        var aggregator = column.aggregate;

        if (Array.isArray(aggregator)) {
          if (aggregator.length !== 2) {
            console.info({
              column: column
            });
            throw new Error("React Table: Complex aggregators must have 2 values, eg. aggregate: ['sum', 'count']. More info above...");
          }

          if (isAggregated) {
            aggregator = aggregator[1];
          } else {
            aggregator = aggregator[0];
          }
        }

        var aggregateFn = typeof aggregator === 'function' ? aggregator : userAggregations[aggregator] || aggregations[aggregator];

        if (aggregateFn) {
          values[column.id] = aggregateFn(columnValues, rows, isAggregated);
        } else if (aggregator) {
          console.info({
            column: column
          });
          throw new Error("React Table: Invalid aggregate option for column listed above");
        } else {
          values[column.id] = null;
        }
      });
      return values;
    };

    var groupedFlatRows = []; // Recursively group the data

    var groupRecursively = function groupRecursively(rows) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      // This is the last level, just return the rows
      if (depth >= groupBy.length) {
        rows.forEach(function (row) {
          row.path = [].concat(_toConsumableArray(parentPath), _toConsumableArray(row.path));
        });
        groupedFlatRows = groupedFlatRows.concat(rows);
        return rows;
      }

      var columnId = groupBy[depth]; // Group the rows together for this level

      var groupedRows = groupByFn(rows, columnId); // Recurse to sub rows before aggregation

      groupedRows = Object.entries(groupedRows).map(function (_ref2, index) {
        var _ref3 = _slicedToArray(_ref2, 2),
            groupByVal = _ref3[0],
            subRows = _ref3[1];

        var path = [].concat(_toConsumableArray(parentPath), ["".concat(columnId, ":").concat(groupByVal)]);
        subRows = groupRecursively(subRows, depth + 1, path);
        var values = aggregateRowsToValues(subRows, depth < groupBy.length);
        var row = {
          isAggregated: true,
          groupByID: columnId,
          groupByVal: groupByVal,
          values: values,
          subRows: subRows,
          depth: depth,
          index: index,
          path: path
        };
        groupedFlatRows.push(row);
        return row;
      });
      return groupedRows;
    };

    var groupedRows = groupRecursively(rows); // Assign the new data

    return [groupedRows, groupedFlatRows];
  }, [manualGroupBy, groupBy, debug, rows, flatRows, flatColumns, userAggregations, groupByFn]),
      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
      groupedRows = _React$useMemo2[0],
      groupedFlatRows = _React$useMemo2[1];

  return _objectSpread2({}, instance, {
    toggleGroupBy: toggleGroupBy,
    rows: groupedRows,
    flatRows: groupedFlatRows,
    preGroupedRows: rows
  });
}

var reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.
// It handles numbers, mixed alphanumeric combinations, and even
// null, undefined, and Infinity

var alphanumeric = function alphanumeric(rowA, rowB, columnId) {
  var a = getRowValueByColumnID(rowA, columnId);
  var b = getRowValueByColumnID(rowB, columnId); // Force to strings (or "" for unsupported types)

  a = toString(a);
  b = toString(b); // Split on number groups, but keep the delimiter
  // Then remove falsey split values

  a = a.split(reSplitAlphaNumeric).filter(Boolean);
  b = b.split(reSplitAlphaNumeric).filter(Boolean); // While

  while (a.length && b.length) {
    var aa = a.shift();
    var bb = b.shift();
    var an = parseInt(aa, 10);
    var bn = parseInt(bb, 10);
    var combo = [an, bn].sort(); // Both are string

    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }

      if (bb > aa) {
        return -1;
      }

      continue;
    } // One is a string, one is a number


    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    } // Both are numbers


    if (an > bn) {
      return 1;
    }

    if (bn > an) {
      return -1;
    }
  }

  return a.length - b.length;
};
function datetime(rowA, rowB, columnId) {
  var a = getRowValueByColumnID(rowA, columnId);
  var b = getRowValueByColumnID(rowB, columnId);
  a = a.getTime();
  b = b.getTime();
  return compareBasic(a, b);
}
function basic(rowA, rowB, columnId) {
  var a = getRowValueByColumnID(rowA, columnId);
  var b = getRowValueByColumnID(rowB, columnId);
  return compareBasic(a, b);
} // Utils

function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}

function getRowValueByColumnID(row, columnId) {
  return row.values[columnId];
}

function toString(a) {
  if (typeof a === 'number') {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return '';
    }

    return String(a);
  }

  if (typeof a === 'string') {
    return a;
  }

  return '';
}

var sortTypes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  alphanumeric: alphanumeric,
  datetime: datetime,
  basic: basic
});

var pluginName$3 = 'useSortBy'; // Actions

actions.resetSortBy = 'resetSortBy';
actions.toggleSortBy = 'toggleSortBy';
actions.clearSortBy = 'clearSortBy'; // Reducer

reducerHandlers[pluginName$3] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      sortBy: []
    }, state);
  }

  if (action.type === actions.resetSortBy) {
    return _objectSpread2({}, state, {
      sortBy: {}
    });
  }

  if (action.type === actions.clearSortBy) {
    var sortBy = state.sortBy;
    var newSortBy = sortBy.filter(function (d) {
      return d.id !== action.columnID;
    });
    return _objectSpread2({}, state, {
      sortBy: newSortBy
    });
  }

  if (action.type === actions.toggleSortBy) {
    var columnId = action.columnId,
        desc = action.desc,
        multi = action.multi,
        _action$instanceRef$c = action.instanceRef.current,
        flatColumns = _action$instanceRef$c.flatColumns,
        disableMultiSort = _action$instanceRef$c.disableMultiSort,
        disableSortRemove = _action$instanceRef$c.disableSortRemove,
        disableMultiRemove = _action$instanceRef$c.disableMultiRemove,
        _action$instanceRef$c2 = _action$instanceRef$c.maxMultiSortColCount,
        maxMultiSortColCount = _action$instanceRef$c2 === void 0 ? Number.MAX_SAFE_INTEGER : _action$instanceRef$c2;
    var _sortBy = state.sortBy; // Find the column for this columnId

    var column = flatColumns.find(function (d) {
      return d.id === columnId;
    });
    var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column

    var existingSortBy = _sortBy.find(function (d) {
      return d.id === columnId;
    });

    var existingIndex = _sortBy.findIndex(function (d) {
      return d.id === columnId;
    });

    var hasDescDefined = typeof desc !== 'undefined' && desc !== null;
    var _newSortBy = []; // What should we do with this sort action?

    var sortAction;

    if (!disableMultiSort && multi) {
      if (existingSortBy) {
        sortAction = 'toggle';
      } else {
        sortAction = 'add';
      }
    } else {
      // Normal mode
      if (existingIndex !== _sortBy.length - 1) {
        sortAction = 'replace';
      } else if (existingSortBy) {
        sortAction = 'toggle';
      } else {
        sortAction = 'replace';
      }
    } // Handle toggle states that will remove the sortBy


    if (sortAction === 'toggle' && // Must be toggling
    !disableSortRemove && // If disableSortRemove, disable in general
    !hasDescDefined && ( // Must not be setting desc
    multi ? !disableMultiRemove : true) && ( // If multi, don't allow if disableMultiRemove
    existingSortBy && // Finally, detect if it should indeed be removed
    existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {
      sortAction = 'remove';
    }

    if (sortAction === 'replace') {
      _newSortBy = [{
        id: columnId,
        desc: hasDescDefined ? desc : sortDescFirst
      }];
    } else if (sortAction === 'add') {
      _newSortBy = [].concat(_toConsumableArray(_sortBy), [{
        id: columnId,
        desc: hasDescDefined ? desc : sortDescFirst
      }]); // Take latest n columns

      _newSortBy.splice(0, _newSortBy.length - maxMultiSortColCount);
    } else if (sortAction === 'toggle') {
      // This flips (or sets) the
      _newSortBy = _sortBy.map(function (d) {
        if (d.id === columnId) {
          return _objectSpread2({}, d, {
            desc: hasDescDefined ? desc : !existingSortBy.desc
          });
        }

        return d;
      });
    } else if (sortAction === 'remove') {
      _newSortBy = _sortBy.filter(function (d) {
        return d.id !== columnId;
      });
    }

    return _objectSpread2({}, state, {
      sortBy: _newSortBy
    });
  }
};

defaultColumn.sortType = 'alphanumeric';
defaultColumn.sortDescFirst = false;
var useSortBy = function useSortBy(hooks) {
  hooks.useMain.push(useMain$3);
};
useSortBy.pluginName = pluginName$3;

function useMain$3(instance) {
  var debug = instance.debug,
      rows = instance.rows,
      flatColumns = instance.flatColumns,
      _instance$orderByFn = instance.orderByFn,
      orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn,
      userSortTypes = instance.sortTypes,
      manualSorting = instance.manualSorting,
      defaultCanSort = instance.defaultCanSort,
      disableSortBy = instance.disableSortBy,
      _instance$isMultiSort = instance.isMultiSortEvent,
      isMultiSortEvent = _instance$isMultiSort === void 0 ? function (e) {
    return e.shiftKey;
  } : _instance$isMultiSort,
      flatHeaders = instance.flatHeaders,
      hooks = instance.hooks,
      sortBy = instance.state.sortBy,
      dispatch = instance.dispatch,
      plugins = instance.plugins,
      _instance$getResetSor = instance.getResetSortByDeps,
      getResetSortByDeps = _instance$getResetSor === void 0 ? false : _instance$getResetSor;
  ensurePluginOrder(plugins, ['useFilters'], 'useSortBy', []); // Add custom hooks

  hooks.getSortByToggleProps = []; // Bypass any effects from firing when this changes

  var isMountedRef = React.useRef();
  safeUseLayoutEffect(function () {
    if (isMountedRef.current) {
      dispatch({
        type: actions.resetSortBy
      });
    }

    isMountedRef.current = true;
  }, [dispatch].concat(_toConsumableArray(getResetSortByDeps ? getResetSortByDeps(instance) : []))); // Updates sorting based on a columnId, desc flag and multi flag

  var toggleSortBy = function toggleSortBy(columnId, desc, multi) {
    dispatch({
      type: actions.toggleSortBy,
      columnId: columnId,
      desc: desc,
      multi: multi
    });
  }; // use reference to avoid memory leak in #1608


  var instanceRef = React.useRef();
  instanceRef.current = instance; // Add the getSortByToggleProps method to columns and headers

  flatHeaders.forEach(function (column) {
    var accessor = column.accessor,
        defaultColumnCanSort = column.canSort,
        columnDisableSortBy = column.disableSortBy,
        id = column.id;
    var canSort = accessor ? getFirstDefined(columnDisableSortBy === true ? false : undefined, disableSortBy === true ? false : undefined, true) : getFirstDefined(defaultCanSort, defaultColumnCanSort, false);
    column.canSort = canSort;

    if (column.canSort) {
      column.toggleSortBy = function (desc, multi) {
        return toggleSortBy(column.id, desc, multi);
      };

      column.clearSortBy = function () {
        dispatch({
          type: actions.clearSortBy,
          columnId: column.id
        });
      };
    }

    column.getSortByToggleProps = function (props) {
      return mergeProps({
        onClick: canSort ? function (e) {
          e.persist();
          column.toggleSortBy(undefined, !instanceRef.current.disableMultiSort && isMultiSortEvent(e));
        } : undefined,
        style: {
          cursor: canSort ? 'pointer' : undefined
        },
        title: 'Toggle SortBy'
      }, applyPropHooks(instanceRef.current.hooks.getSortByToggleProps, column, instanceRef.current), props);
    };

    var columnSort = sortBy.find(function (d) {
      return d.id === id;
    });
    column.isSorted = !!columnSort;
    column.sortedIndex = sortBy.findIndex(function (d) {
      return d.id === id;
    });
    column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;
  });
  var sortedRows = React.useMemo(function () {
    if (manualSorting || !sortBy.length) {
      return rows;
    }

    if (process.env.NODE_ENV !== 'production' && debug) console.time('getSortedRows'); // Filter out sortBys that correspond to non existing columns

    var availableSortBy = sortBy.filter(function (sort) {
      return flatColumns.find(function (col) {
        return col.id === sort.id;
      });
    });

    var sortData = function sortData(rows) {
      // Use the orderByFn to compose multiple sortBy's together.
      // This will also perform a stable sorting using the row index
      // if needed.
      var sortedData = orderByFn(rows, availableSortBy.map(function (sort) {
        // Support custom sorting methods for each column
        var column = flatColumns.find(function (d) {
          return d.id === sort.id;
        });

        if (!column) {
          throw new Error("React-Table: Could not find a column with id: ".concat(sort.id, " while sorting"));
        }

        var sortType = column.sortType; // Look up sortBy functions in this order:
        // column function
        // column string lookup on user sortType
        // column string lookup on built-in sortType
        // default function
        // default string lookup on user sortType
        // default string lookup on built-in sortType

        var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];

        if (!sortMethod) {
          throw new Error("React-Table: Could not find a valid sortType of '".concat(sortType, "' for column '").concat(sort.id, "'."));
        } // Return the correct sortFn.
        // This function should always return in ascending order


        return function (a, b) {
          return sortMethod(a, b, sort.id);
        };
      }), // Map the directions
      availableSortBy.map(function (sort) {
        // Detect and use the sortInverted option
        var column = flatColumns.find(function (d) {
          return d.id === sort.id;
        });

        if (column && column.sortInverted) {
          return sort.desc;
        }

        return !sort.desc;
      })); // If there are sub-rows, sort them

      sortedData.forEach(function (row) {
        if (!row.subRows || row.subRows.length <= 1) {
          return;
        }

        row.subRows = sortData(row.subRows);
      });
      return sortedData;
    };

    if (process.env.NODE_ENV !== 'production' && debug) console.timeEnd('getSortedRows');
    return sortData(rows);
  }, [manualSorting, sortBy, debug, rows, flatColumns, orderByFn, userSortTypes]);
  return _objectSpread2({}, instance, {
    toggleSortBy: toggleSortBy,
    rows: sortedRows,
    preSortedRows: rows
  });
}

var pluginName$4 = 'usePagination'; // Actions

actions.resetPage = 'resetPage';
actions.gotoPage = 'gotoPage';
actions.setPageSize = 'setPageSize'; // Reducer

reducerHandlers[pluginName$4] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      pageSize: 10,
      pageIndex: 0
    }, state);
  }

  if (action.type === actions.resetPage) {
    return _objectSpread2({}, state, {
      pageIndex: 0
    });
  }

  if (action.type === actions.gotoPage) {
    var pageCount = action.instanceRef.current.pageCount;
    var newPageIndex = functionalUpdate(action.pageIndex, state.pageIndex);

    if (newPageIndex < 0 || newPageIndex > pageCount - 1) {
      return state;
    }

    return _objectSpread2({}, state, {
      pageIndex: newPageIndex
    });
  }

  if (action.type === actions.setPageSize) {
    var pageSize = action.pageSize;
    var topRowIndex = state.pageSize * state.pageIndex;
    var pageIndex = Math.floor(topRowIndex / pageSize);
    return _objectSpread2({}, state, {
      pageIndex: pageIndex,
      pageSize: pageSize
    });
  }
};

var usePagination = function usePagination(hooks) {
  hooks.useMain.push(useMain$4);
};
usePagination.pluginName = pluginName$4;

var defaultGetResetPageDeps = function defaultGetResetPageDeps(_ref) {
  var data = _ref.data,
      manualPagination = _ref.manualPagination,
      _ref$state = _ref.state,
      filters = _ref$state.filters,
      groupBy = _ref$state.groupBy,
      sortBy = _ref$state.sortBy;
  return [manualPagination ? null : data, filters, groupBy, sortBy];
};

function useMain$4(instance) {
  var rows = instance.rows,
      manualPagination = instance.manualPagination,
      _instance$getResetPag = instance.getResetPageDeps,
      getResetPageDeps = _instance$getResetPag === void 0 ? defaultGetResetPageDeps : _instance$getResetPag,
      _instance$manualExpan = instance.manualExpandedKey,
      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,
      debug = instance.debug,
      plugins = instance.plugins,
      userPageCount = instance.pageCount,
      _instance$paginateExp = instance.paginateExpandedRows,
      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,
      _instance$expandSubRo = instance.expandSubRows,
      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,
      _instance$state = instance.state,
      pageSize = _instance$state.pageSize,
      pageIndex = _instance$state.pageIndex,
      expanded = _instance$state.expanded,
      dispatch = instance.dispatch;
  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'], 'usePagination', []); // Bypass any effects from firing when this changes

  var isMountedRef = React.useRef();
  safeUseLayoutEffect(function () {
    if (isMountedRef.current) {
      dispatch({
        type: actions.resetPage
      });
    }

    isMountedRef.current = true;
  }, [dispatch].concat(_toConsumableArray(getResetPageDeps ? getResetPageDeps(instance) : [])));
  var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);
  var pageOptions = React.useMemo(function () {
    return pageCount > 0 ? _toConsumableArray(new Array(pageCount)).map(function (d, i) {
      return i;
    }) : [];
  }, [pageCount]);
  var page = React.useMemo(function () {
    var page;

    if (manualPagination) {
      page = rows;
    } else {
      if (process.env.NODE_ENV !== 'production' && debug) console.info('getPage');
      var pageStart = pageSize * pageIndex;
      var pageEnd = pageStart + pageSize;
      page = rows.slice(pageStart, pageEnd);
    }

    if (paginateExpandedRows) {
      return page;
    }

    return expandRows(page, {
      manualExpandedKey: manualExpandedKey,
      expanded: expanded,
      expandSubRows: expandSubRows
    });
  }, [debug, expandSubRows, expanded, manualExpandedKey, manualPagination, pageIndex, pageSize, paginateExpandedRows, rows]);
  var canPreviousPage = pageIndex > 0;
  var canNextPage = pageCount === -1 || pageIndex < pageCount - 1;
  var gotoPage = React.useCallback(function (pageIndex) {
    dispatch({
      type: actions.gotoPage,
      pageIndex: pageIndex
    });
  }, [dispatch]);
  var previousPage = React.useCallback(function () {
    return gotoPage(function (old) {
      return old - 1;
    });
  }, [gotoPage]);
  var nextPage = React.useCallback(function () {
    return gotoPage(function (old) {
      return old + 1;
    });
  }, [gotoPage]);
  var setPageSize = React.useCallback(function (pageSize) {
    dispatch({
      type: actions.setPageSize,
      pageSize: pageSize
    });
  }, [dispatch]);
  return _objectSpread2({}, instance, {
    pageOptions: pageOptions,
    pageCount: pageCount,
    page: page,
    canPreviousPage: canPreviousPage,
    canNextPage: canNextPage,
    gotoPage: gotoPage,
    previousPage: previousPage,
    nextPage: nextPage,
    setPageSize: setPageSize,
    pageIndex: pageIndex,
    pageSize: pageSize
  });
}

var pluginName$5 = 'useRowSelect'; // Actions

actions.resetSelectedRows = 'resetSelectedRows';
actions.toggleRowSelectedAll = 'toggleRowSelectedAll';
actions.toggleRowSelected = 'toggleRowSelected'; // Reducer

reducerHandlers[pluginName$5] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      selectedRowPaths: []
    }, state);
  }

  if (action.type === actions.resetSelectedRows) {
    return _objectSpread2({}, state, {
      selectedRowPaths: []
    });
  }

  if (action.type === actions.toggleRowSelectedAll) {
    var selected = action.selected,
        _action$instanceRef$c = action.instanceRef.current,
        isAllRowsSelected = _action$instanceRef$c.isAllRowsSelected,
        flatRowPaths = _action$instanceRef$c.flatRowPaths;
    var selectAll = typeof selected !== 'undefined' ? selected : !isAllRowsSelected;
    return _objectSpread2({}, state, {
      selectedRowPaths: selectAll ? flatRowPaths : []
    });
  }

  if (action.type === actions.toggleRowSelected) {
    var path = action.path,
        _selected = action.selected,
        _flatRowPaths = action.instanceRef.current.flatRowPaths;
    var key = path.join('.');
    var childRowPrefixKey = [key, '.'].join(''); // Join the paths of deep rows
    // to make a key, then manage all of the keys
    // in a flat object

    var exists = state.selectedRowPaths.includes(key);
    var shouldExist = typeof set !== 'undefined' ? _selected : !exists;
    var newSelectedRows = new Set(state.selectedRowPaths);

    if (!exists && shouldExist) {
      _flatRowPaths.forEach(function (rowPath) {
        if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {
          newSelectedRows.add(rowPath);
        }
      });
    } else if (exists && !shouldExist) {
      _flatRowPaths.forEach(function (rowPath) {
        if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {
          newSelectedRows.delete(rowPath);
        }
      });
    } else {
      return state;
    }

    var updateParentRow = function updateParentRow(selectedRowPaths, path) {
      var parentPath = path.slice(0, path.length - 1);
      var parentKey = parentPath.join('.');
      var selected = _flatRowPaths.filter(function (rowPath) {
        var path = rowPath;
        return path !== parentKey && path.startsWith(parentKey) && !selectedRowPaths.has(path);
      }).length === 0;

      if (selected) {
        selectedRowPaths.add(parentKey);
      } else {
        selectedRowPaths.delete(parentKey);
      }

      if (parentPath.length > 1) updateParentRow(selectedRowPaths, parentPath);
    }; // If the row is a subRow update
    // its parent row to reflect changes


    if (path.length > 1) updateParentRow(newSelectedRows, path);
    return _objectSpread2({}, state, {
      selectedRowPaths: _toConsumableArray(newSelectedRows.values())
    });
  }
};

var useRowSelect = function useRowSelect(hooks) {
  hooks.getToggleRowSelectedProps = [];
  hooks.getToggleAllRowsSelectedProps = [];
  hooks.useRows.push(useRows);
  hooks.useMain.push(useMain$5);
};
useRowSelect.pluginName = pluginName$5;

function useRows(rows, instance) {
  var selectedRowPaths = instance.state.selectedRowPaths;
  instance.selectedFlatRows = React.useMemo(function () {
    var selectedFlatRows = [];
    rows.forEach(function (row) {
      row.isSelected = getRowIsSelected(row, selectedRowPaths);

      if (row.isSelected) {
        selectedFlatRows.push(row);
      }
    });
    return selectedFlatRows;
  }, [rows, selectedRowPaths]);
  return rows;
}

var defaultGetResetSelectedRowPathsDeps = function defaultGetResetSelectedRowPathsDeps(_ref) {
  var data = _ref.data;
  return [data];
};

function useMain$5(instance) {
  var hooks = instance.hooks,
      _instance$manualRowSe = instance.manualRowSelectedKey,
      manualRowSelectedKey = _instance$manualRowSe === void 0 ? 'isSelected' : _instance$manualRowSe,
      plugins = instance.plugins,
      flatRows = instance.flatRows,
      _instance$getResetSel = instance.getResetSelectedRowPathsDeps,
      getResetSelectedRowPathsDeps = _instance$getResetSel === void 0 ? defaultGetResetSelectedRowPathsDeps : _instance$getResetSel,
      selectedRowPaths = instance.state.selectedRowPaths,
      dispatch = instance.dispatch;
  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy'], 'useRowSelect', []);
  var flatRowPaths = flatRows.map(function (d) {
    return d.path.join('.');
  });
  var isAllRowsSelected = !!flatRowPaths.length && !!selectedRowPaths.length;

  if (isAllRowsSelected) {
    if (flatRowPaths.some(function (d) {
      return !selectedRowPaths.includes(d);
    })) {
      isAllRowsSelected = false;
    }
  } // Bypass any effects from firing when this changes


  var isMountedRef = React.useRef();
  safeUseLayoutEffect(function () {
    if (isMountedRef.current) {
      dispatch({
        type: actions.resetSelectedRows
      });
    }

    isMountedRef.current = true;
  }, [dispatch].concat(_toConsumableArray(getResetSelectedRowPathsDeps ? getResetSelectedRowPathsDeps(instance) : [])));

  var toggleRowSelectedAll = function toggleRowSelectedAll(selected) {
    return dispatch({
      type: actions.toggleRowSelectedAll,
      selected: selected
    });
  };

  var toggleRowSelected = function toggleRowSelected(path, selected) {
    return dispatch({
      type: actions.toggleRowSelected,
      path: path,
      selected: selected
    });
  }; // use reference to avoid memory leak in #1608


  var instanceRef = React.useRef();
  instanceRef.current = instance;

  var getToggleAllRowsSelectedProps = function getToggleAllRowsSelectedProps(props) {
    return mergeProps({
      onChange: function onChange(e) {
        toggleRowSelectedAll(e.target.checked);
      },
      style: {
        cursor: 'pointer'
      },
      checked: isAllRowsSelected,
      title: 'Toggle All Rows Selected'
    }, applyPropHooks(instanceRef.current.hooks.getToggleAllRowsSelectedProps, instanceRef.current), props);
  };

  hooks.prepareRow.push(function (row) {
    row.toggleRowSelected = function (set) {
      return toggleRowSelected(row.path, set);
    };

    row.getToggleRowSelectedProps = function (props) {
      var checked = false;

      if (row.original && row.original[manualRowSelectedKey]) {
        checked = true;
      } else {
        checked = row.isSelected;
      }

      return mergeProps({
        onChange: function onChange(e) {
          row.toggleRowSelected(e.target.checked);
        },
        style: {
          cursor: 'pointer'
        },
        checked: checked,
        title: 'Toggle Row Selected'
      }, applyPropHooks(instanceRef.current.hooks.getToggleRowSelectedProps, row, instanceRef.current), props);
    };

    return row;
  });
  return _objectSpread2({}, instance, {
    flatRowPaths: flatRowPaths,
    toggleRowSelected: toggleRowSelected,
    toggleRowSelectedAll: toggleRowSelectedAll,
    getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps,
    isAllRowsSelected: isAllRowsSelected
  });
}

function getRowIsSelected(row, selectedRowPaths) {
  if (row.isAggregated) {
    return row.subRows.every(function (subRow) {
      return getRowIsSelected(subRow, selectedRowPaths);
    });
  }

  return selectedRowPaths.includes(row.path.join('.'));
}

var pluginName$6 = 'useRowState'; // Actions

actions.setRowState = 'setRowState';
actions.resetRowState = 'resetRowState'; // Reducer

reducerHandlers[pluginName$6] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      rowState: {}
    }, state);
  }

  if (action.type === actions.resetRowState) {
    return _objectSpread2({}, state, {
      rowState: {}
    });
  }

  if (action.type === actions.setRowState) {
    var path = action.path,
        value = action.value;
    var pathKey = path.join('.');
    return _objectSpread2({}, state, {
      rowState: _objectSpread2({}, state.rowState, _defineProperty({}, pathKey, functionalUpdate(value, state.rowState[pathKey])))
    });
  }
};

var useRowState = function useRowState(hooks) {
  hooks.useMain.push(useMain$6);
};
useRowState.pluginName = pluginName$6;

var defaultGetResetRowStateDeps = function defaultGetResetRowStateDeps(_ref) {
  var data = _ref.data;
  return [data];
};

function useMain$6(instance) {
  var hooks = instance.hooks,
      initialRowStateAccessor = instance.initialRowStateAccessor,
      _instance$getResetRow = instance.getResetRowStateDeps,
      getResetRowStateDeps = _instance$getResetRow === void 0 ? defaultGetResetRowStateDeps : _instance$getResetRow,
      rowState = instance.state.rowState,
      dispatch = instance.dispatch;
  var setRowState = React.useCallback(function (path, value, columnId) {
    return dispatch({
      type: actions.setRowState,
      path: path,
      value: value,
      columnId: columnId
    });
  }, [dispatch]);
  var setCellState = React.useCallback(function (rowPath, columnId, updater) {
    return setRowState(rowPath, function (old) {
      return _objectSpread2({}, old, {
        cellState: _objectSpread2({}, old.cellState, _defineProperty({}, columnId, typeof updater === 'function' ? updater(old.cellState[columnId]) : updater))
      });
    }, columnId);
  }, [setRowState]);
  var rowsMountedRef = React.useRef(); // When data changes, reset row and cell state

  safeUseLayoutEffect(function () {
    if (rowsMountedRef.current) {
      dispatch({
        type: actions.resetRowState
      });
    }

    rowsMountedRef.current = true;
  }, [dispatch].concat(_toConsumableArray(getResetRowStateDeps ? getResetRowStateDeps(instance) : [])));
  hooks.prepareRow.push(function (row) {
    var pathKey = row.path.join('.');

    if (row.original) {
      row.state = (typeof rowState[pathKey] !== 'undefined' ? rowState[pathKey] : initialRowStateAccessor && initialRowStateAccessor(row)) || {};

      row.setState = function (updater) {
        return setRowState(row.path, updater);
      };

      row.cells.forEach(function (cell) {
        cell.state = row.state.cellState || {};

        cell.setState = function (updater) {
          return setCellState(row.path, cell.column.id, updater);
        };
      });
    }

    return row;
  });
  return _objectSpread2({}, instance, {
    setRowState: setRowState,
    setCellState: setCellState
  });
}

var pluginName$7 = 'useColumnOrder'; // Actions

actions.resetColumnOrder = 'resetColumnOrder';
actions.setColumnOrder = 'setColumnOrder'; // Reducer

reducerHandlers[pluginName$7] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      columnOrder: []
    }, state);
  }

  if (action.type === actions.resetColumnOrder) {
    return _objectSpread2({}, state, {
      columnOrder: []
    });
  }

  if (action.type === actions.setColumnOrder) {
    return _objectSpread2({}, state, {
      columnOrder: functionalUpdate(action.columnOrder, state.columnOrder)
    });
  }
};

var useColumnOrder = function useColumnOrder(hooks) {
  hooks.columnsBeforeHeaderGroupsDeps.push(function (deps, instance) {
    return [].concat(_toConsumableArray(deps), [instance.state.columnOrder]);
  });
  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups$1);
  hooks.useMain.push(useMain$7);
};
useColumnOrder.pluginName = pluginName$7;

function columnsBeforeHeaderGroups$1(columns, instance) {
  var columnOrder = instance.state.columnOrder; // If there is no order, return the normal columns

  if (!columnOrder || !columnOrder.length) {
    return columns;
  }

  var columnOrderCopy = _toConsumableArray(columnOrder); // If there is an order, make a copy of the columns


  var columnsCopy = _toConsumableArray(columns); // And make a new ordered array of the columns


  var columnsInOrder = []; // Loop over the columns and place them in order into the new array

  var _loop = function _loop() {
    var targetColumnId = columnOrderCopy.shift();
    var foundIndex = columnsCopy.findIndex(function (d) {
      return d.id === targetColumnId;
    });

    if (foundIndex > -1) {
      columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);
    }
  };

  while (columnsCopy.length && columnOrderCopy.length) {
    _loop();
  } // If there are any columns left, add them to the end


  return [].concat(columnsInOrder, _toConsumableArray(columnsCopy));
}

function useMain$7(instance) {
  var dispatch = instance.dispatch;
  var setColumnOrder = React.useCallback(function (columnOrder) {
    return dispatch({
      type: actions.setColumnOrder,
      columnOrder: columnOrder
    });
  }, [dispatch]);
  return _objectSpread2({}, instance, {
    setColumnOrder: setColumnOrder
  });
}

var pluginName$8 = 'useResizeColumns'; // Default Column

defaultColumn.canResize = true; // Actions

actions.columnStartResizing = 'columnStartResizing';
actions.columnResizing = 'columnResizing';
actions.columnDoneResizing = 'columnDoneResizing'; // Reducer

reducerHandlers[pluginName$8] = function (state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      columnResizing: {
        columnWidths: {}
      }
    }, state);
  }

  if (action.type === actions.columnStartResizing) {
    var startX = action.startX,
        columnId = action.columnId,
        headerIdWidths = action.headerIdWidths;
    return _objectSpread2({}, state, {
      columnResizing: _objectSpread2({}, state.columnResizing, {
        startX: startX,
        headerIdWidths: headerIdWidths,
        isResizingColumn: columnId
      })
    });
  }

  if (action.type === actions.columnResizing) {
    var clientX = action.clientX;
    var _state$columnResizing = state.columnResizing,
        _startX = _state$columnResizing.startX,
        _headerIdWidths = _state$columnResizing.headerIdWidths;
    var deltaX = clientX - _startX;
    var percentageDeltaX = deltaX / _headerIdWidths.length;
    var newColumnWidths = {};

    _headerIdWidths.forEach(function (_ref, index) {
      var _ref2 = _slicedToArray(_ref, 2),
          headerId = _ref2[0],
          headerWidth = _ref2[1];

      newColumnWidths[headerId] = Math.max(headerWidth + percentageDeltaX, 0);
    });

    return _objectSpread2({}, state, {
      columnResizing: _objectSpread2({}, state.columnResizing, {
        columnWidths: _objectSpread2({}, state.columnResizing.columnWidths, {}, action.columnWidths)
      })
    });
  }

  if (action.type === actions.columnDoneResizing) {
    return _objectSpread2({}, state, {
      columnResizing: _objectSpread2({}, state.columnResizing, {
        startX: null,
        isResizingColumn: null
      })
    });
  }
};

var useResizeColumns = function useResizeColumns(hooks) {
  hooks.useBeforeDimensions.push(useBeforeDimensions);
};
useResizeColumns.pluginName = pluginName$8;

var useBeforeDimensions = function useBeforeDimensions(instance) {
  instance.hooks.getResizerProps = [];
  var flatHeaders = instance.flatHeaders,
      disableResizing = instance.disableResizing,
      getHeaderProps = instance.hooks.getHeaderProps,
      columnResizing = instance.state.columnResizing,
      dispatch = instance.dispatch;
  getHeaderProps.push(function () {
    return {
      style: {
        position: 'relative'
      }
    };
  });

  var _onMouseDown = function onMouseDown(e, header) {
    var headersToResize = getLeafHeaders(header);
    var headerIdWidths = headersToResize.map(function (d) {
      return [d.id, d.totalWidth];
    });
    var clientX = e.clientX;

    var onMouseMove = function onMouseMove(e) {
      var clientX = e.clientX;
      dispatch({
        type: actions.columnResizing,
        clientX: clientX
      });
    };

    var onMouseUp = function onMouseUp(e) {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      dispatch({
        type: actions.columnDoneResizing
      });
    };

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
    dispatch({
      type: actions.columnStartResizing,
      columnId: header.id,
      headerIdWidths: headerIdWidths,
      clientX: clientX
    });
  }; // use reference to avoid memory leak in #1608


  var instanceRef = React.useRef();
  instanceRef.current = instance;
  flatHeaders.forEach(function (header) {
    var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);
    header.canResize = canResize;
    header.width = columnResizing.columnWidths[header.id] || header.width;
    header.isResizing = columnResizing.isResizingColumn === header.id;

    if (canResize) {
      header.getResizerProps = function (userProps) {
        return mergeProps({
          onMouseDown: function onMouseDown(e) {
            return e.persist() || _onMouseDown(e, header);
          },
          style: {
            cursor: 'ew-resize'
          },
          draggable: false
        }, applyPropHooks(instanceRef.current.hooks.getResizerProps, header, instanceRef.current), userProps);
      };
    }
  });
  return instance;
};

function getLeafHeaders(header) {
  var leafHeaders = [];

  var recurseHeader = function recurseHeader(header) {
    if (header.columns && header.columns.length) {
      header.columns.map(recurseHeader);
    }

    leafHeaders.push(header);
  };

  recurseHeader(header);
  return leafHeaders;
}

var useAbsoluteLayout = function useAbsoluteLayout(hooks) {
  hooks.useMain.push(useMain$8);
};
useAbsoluteLayout.pluginName = 'useAbsoluteLayout';

var useMain$8 = function useMain(instance) {
  var totalColumnsWidth = instance.totalColumnsWidth,
      _instance$hooks = instance.hooks,
      getRowProps = _instance$hooks.getRowProps,
      getTableBodyProps = _instance$hooks.getTableBodyProps,
      getHeaderGroupProps = _instance$hooks.getHeaderGroupProps,
      getHeaderProps = _instance$hooks.getHeaderProps,
      getCellProps = _instance$hooks.getCellProps;
  var rowStyles = {
    style: {
      position: 'relative',
      width: "".concat(totalColumnsWidth, "px")
    }
  };
  getTableBodyProps.push(function () {
    return rowStyles;
  });
  getRowProps.push(function () {
    return rowStyles;
  });
  getHeaderGroupProps.push(function () {
    return rowStyles;
  }); // Calculating column/cells widths

  var cellStyles = {
    position: 'absolute',
    top: 0
  };
  getHeaderProps.push(function (header) {
    return {
      style: _objectSpread2({}, cellStyles, {
        left: "".concat(header.totalLeft, "px"),
        width: "".concat(header.totalWidth, "px")
      })
    };
  });
  getCellProps.push(function (cell) {
    return {
      style: _objectSpread2({}, cellStyles, {
        left: "".concat(cell.column.totalLeft, "px"),
        width: "".concat(cell.column.totalWidth, "px")
      })
    };
  });
  return instance;
};

var useBlockLayout = function useBlockLayout(hooks) {
  hooks.useMain.push(useMain$9);
};
useBlockLayout.pluginName = 'useBlockLayout';

var useMain$9 = function useMain(instance) {
  var totalColumnsWidth = instance.totalColumnsWidth,
      _instance$hooks = instance.hooks,
      getRowProps = _instance$hooks.getRowProps,
      getHeaderGroupProps = _instance$hooks.getHeaderGroupProps,
      getHeaderProps = _instance$hooks.getHeaderProps,
      getCellProps = _instance$hooks.getCellProps;
  var rowStyles = {
    style: {
      display: 'flex',
      width: "".concat(totalColumnsWidth, "px")
    }
  };
  getRowProps.push(function () {
    return rowStyles;
  });
  getHeaderGroupProps.push(function () {
    return rowStyles;
  });
  var cellStyles = {
    display: 'inline-block',
    boxSizing: 'border-box'
  };
  getHeaderProps.push(function (header) {
    return {
      style: _objectSpread2({}, cellStyles, {
        width: "".concat(header.totalWidth, "px")
      })
    };
  });
  getCellProps.push(function (cell) {
    return {
      style: _objectSpread2({}, cellStyles, {
        width: "".concat(cell.column.totalWidth, "px")
      })
    };
  });
  return instance;
};

export { actions, defaultColumn, reducerHandlers, useAbsoluteLayout, useBlockLayout, useColumnOrder, useExpanded, useFilters, useGroupBy, usePagination, useResizeColumns, useRowSelect, useRowState, useSortBy, useTable, utils };
//# sourceMappingURL=index.es.js.map
